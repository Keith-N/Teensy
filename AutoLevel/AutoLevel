/* Teensy 3.5 
 *
 * Autolevel
 * 
 * 3-21-19 
 * 
*/

/////////////////////////////////////////////////////////
//LIBARIES 
/////////////////////////////////////////////////////////
#include <Arduino.h> //Used for Visual Studio's code 
#include <Wire.h>    //I2C communication 
#include <Adafruit_Sensor.h>
#include <Adafruit_FXAS21002C.h>
#include <Adafruit_FXOS8700.h>
#include <Mahony.h>
#include <Madgwick.h>
#define AHRS_VARIANT   NXP_FXOS8700_FXAS21002

/////////////////////////////////////////////////////////
//Random
/////////////////////////////////////////////////////////

elapsedMicros elapsedTime;
int loop_counter;

/////////////////////////////////////////////////////////
//SWITCHS
/////////////////////////////////////////////////////////
bool debug = false; 

bool print = false; 
int printTimer = 5000;
int lastPrint = 0;

////////////////////////////////////////////////////////
//PIN DEFINITIONS
////////////////////////////////////////////////////////

// Reciever  
int ch1 = 7;
int ch2 = 8;
int ch3 = 14;
int ch4 = 35;
int ch5 = 33;

// esc
int escOut1 = 5;
int escOut2 = 6;
int escOut3 = 10;
int escOut4 = 20;

// led 
int led = 13; 

// Battery 
int battery = 2;

/////////////////////////////////////////////////////////
// PWM Variables 
/////////////////////////////////////////////////////////

 // Get maximum value for selected PWM resolution (100% Duty)
 int pwmMax = 256;
 // Initializing pulse for ESCs, 25% duty
 int escInit = pwmMax/4;

 int pwmFreq = 250;
 int pwmRes = 8;
 int escPulseTime = 4000;

 // Pulse length 
 int escPulse1;
 int escPulse2;
 int escPulse3;
 int escPulse4;

 // signal for analog write 
 int escPulse1PWM;
 int escPulse2PWM;
 int escPulse3PWM;
 int escPulse4PWM;

 /////////////////////////////////////////////////////////
// IMU 
/////////////////////////////////////////////////////////

 float pitch, roll, yaw;
 float pitch_rate, roll_rate, yaw_rate;

Adafruit_FXAS21002C gyro = Adafruit_FXAS21002C(0x0021002C);
Adafruit_FXOS8700 accelmag = Adafruit_FXOS8700(0x8700A, 0x8700B);

// Calibration 

// Offsets applied to raw x/y/z mag values
 float mag_offsets[3] = { -1.32F, -14.71F, 43.91F };

// Soft iron error compensation matrix
 float mag_softiron_matrix[3][3] = { {  0.999,  -0.037,  -0.009 },
									 {  -0.037,  0.988, 0.008 },
									 {  -0.009, 0.008,  1.014 } };

 float mag_field_strength = 38.21F;

// Offsets applied to compensate for gyro zero-drift error for x/y/z
 float gyro_zero_offsets[3]      = { 0.0F, 0.0F, 0.0F };

// Filter type
 Mahony filter;
 //Madgwick filter;

 // Filter sample rate
 int updateFreq = 250;
 int updateTime = 1000000*(1/updateFreq);
 int lastUpdate = 0;

 void getIMU()
{
	 sensors_event_t gyro_event;
	 sensors_event_t accel_event;
	 sensors_event_t mag_event;
	 gyro.getEvent(&gyro_event);
	 accelmag.getEvent(&accel_event, &mag_event);

	 // Apply mag offset compensation (base values in uTesla)
	 float x = mag_event.magnetic.x - mag_offsets[0];
	 float y = mag_event.magnetic.y - mag_offsets[1];
	 float z = mag_event.magnetic.z - mag_offsets[2];

	 // Apply mag soft iron error compensation
	 float mx = x * mag_softiron_matrix[0][0] + y * mag_softiron_matrix[0][1] + z * mag_softiron_matrix[0][2];
	 float my = x * mag_softiron_matrix[1][0] + y * mag_softiron_matrix[1][1] + z * mag_softiron_matrix[1][2];
	 float mz = x * mag_softiron_matrix[2][0] + y * mag_softiron_matrix[2][1] + z * mag_softiron_matrix[2][2];

	 // Apply gyro zero-rate error compensation
	 float gx = gyro_event.gyro.x + gyro_zero_offsets[0];
	 float gy = gyro_event.gyro.y + gyro_zero_offsets[1];
	 float gz = gyro_event.gyro.z + gyro_zero_offsets[2];

	 // The filter library expects gyro data in degrees/s, but adafruit sensor
	 // uses rad/s so we need to convert them first (or adapt the filter lib
	 // where they are being converted)
	 gx *= 57.2958F;
	 gy *= 57.2958F;
	 gz *= 57.2958F;

		filter.update(gx, gy, gz,
								 accel_event.acceleration.x, accel_event.acceleration.y, accel_event.acceleration.z,
								 mx, my, mz);

	 // Degrees  
	 pitch = filter.getRoll();
	 roll = filter.getPitch();
	 yaw = -1*filter.getYaw();

	 // Degrees per second 
	 pitch_rate = gyro_event.gyro.x*(180/3.14);
	 roll_rate = gyro_event.gyro.y*(180/3.14);
	 yaw_rate = -1*gyro_event.gyro.z*(180/3.14);
}

/////////////////////////////////////////////////////////
// PWM Variables 
/////////////////////////////////////////////////////////

 /////////////////////////////////////////////////////////
 // INTERUPTS
 /////////////////////////////////////////////////////////

 // Timing Variables for Pulse Width
 unsigned long prev1 = 0;
 volatile unsigned long roll_ratePulse = 1500;
 unsigned long prev2 = 0;
 volatile unsigned long pitch_ratePulse = 1500;
 unsigned long prev3 = 0;
 volatile unsigned long throttle_Pulse = 1500;
 unsigned long prev4 = 0;
 volatile unsigned long yaw_ratePulse = 1500;
 unsigned long prev5 = 0;
 volatile unsigned long delta5 = 1500;


 // Get pulse timing 

 // Roll 
 void ch1Int()
{
  if (digitalReadFast(ch1)){
	prev1 = micros();
  }
  else{
	roll_ratePulse = micros() - prev1;
  }
}

// Pitch 
void ch2Int()
{
  if (digitalReadFast(ch2)){
	prev2 = micros();
  }
  else{
	pitch_ratePulse = micros() - prev2;
  }
}

// Throttle 
void ch3Int()
{
   if (digitalReadFast(ch3)){
	prev3 = micros();
   }
   else{
	throttle_Pulse = micros() - prev3;
   }  
}

// Yaw 
void ch4Int()
{
   if (digitalReadFast(ch4)){
	prev4 = micros();
   }
   else{
	yaw_ratePulse = micros() - prev4;
   }
}

// Switch 
void ch5Int()
{
   if (digitalReadFast(ch5)){
	prev5 = micros();
   }
   else{
	delta5 = micros() - prev5;
   }
}

/////////////////////////////////////////////////////////
// Controller Calibration  
/////////////////////////////////////////////////////////
int throttleMax;
int throttleMin; 

int roll_rateCenter = 1500;

int pitch_rateCenter = 1500;

int yaw_rateCenter = 1500;


 /////////////////////////////////////////////////////////
// PID 
/////////////////////////////////////////////////////////

// Pitch Variables 
int inputPitch;
int errorPitch; 
int pitchPulse;
int last_errorPitch;
int Ipitch;

int pPitch = 1;
int dPitch = 1;
int iPitch = 1;

// Roll Variables 
int inputRoll;
int errorRoll; 
int rollPulse;
int last_errorRoll;
int Iroll;

int pRoll = 1;
int dRoll = 1;
int iRoll = 1;

// Yaw Variables 
int inputYaw;
int errorYaw; 
int yawPulse;
int last_errorYaw;

int pYaw = 1;
int dYaw = 1;



void PID()
{
	inputPitch = pitch_rateCenter - pitch_ratePulse;
	errorPitch = inputPitch - pitch_rate;
	Ipitch += iPitch*(errorPitch - last_errorPitch); 
	pitchPulse = pPitch*errorPitch + dPitch*(errorPitch - last_errorPitch) + Ipitch;
	last_errorPitch = errorPitch;

	inputRoll = roll_ratePulse - roll_rateCenter;
	errorRoll = inputRoll - roll_rate;
	Iroll += iRoll*(errorRoll - last_errorRoll);
	rollPulse = pRoll*errorRoll + dRoll*(errorRoll - last_errorRoll) + Iroll;
	last_errorRoll = errorRoll;

	// Don't know what other gains are need here
	inputYaw = yaw_ratePulse - yaw_rateCenter;
	errorYaw = inputYaw - yaw_rate;
	yawPulse = pYaw*errorYaw;
	last_errorYaw = errorYaw;

}


void setup() 
{
	// Set up Serial monitor 
	if(print == true || debug == true)  
	{
		Serial.begin(115200);
		while(!Serial);
	}

	// Set pin direction 
	pinMode(ch1,INPUT);
	pinMode(ch2,INPUT);
	pinMode(ch3,INPUT);
	pinMode(ch4,INPUT);

	pinMode(escOut1,OUTPUT);
	pinMode(escOut2,OUTPUT);
	pinMode(escOut3,OUTPUT);
	pinMode(escOut4,OUTPUT);

	pinMode(led,OUTPUT);
	pinMode(battery,INPUT);

	// Initilize IMU 
	if(!gyro.begin(GYRO_RANGE_500DPS))
	{
		/* There was a problem detecting the gyro ... check your connections */
		Serial.println("Ooops, no gyro detected ... Check your wiring!");
		while(1);
	}

	if(!accelmag.begin(ACCEL_RANGE_4G))
	{
		Serial.println("Ooops, no FXOS8700 detected ... Check your wiring!");
		while(1);
	}

	filter.begin(updateFreq);

	// Wait for battery to be plugged in 
	// while(digitalRead(battery) == 0);

	//Setup rx pin interrupts
  	attachInterrupt(ch1,ch1Int,CHANGE);
  	attachInterrupt(ch2,ch2Int,CHANGE);
  	attachInterrupt(ch3,ch3Int,CHANGE);
  	attachInterrupt(ch4,ch4Int,CHANGE);
	attachInterrupt(ch5,ch5Int,CHANGE);
	
	// All on Timer FTM0 -> pwmFreq
  	analogWriteFrequency(escOut1, pwmFreq);

  	// Set PWM resolution
  	analogWriteResolution(pwmRes);
	
	// Initialize ESCs
  	analogWrite(escOut1, escInit);
  	analogWrite(escOut2, escInit);
  	analogWrite(escOut3, escInit);
  	analogWrite(escOut4, escInit);
  	delay(5000);

	// Setup complete 
	digitalWrite(led,HIGH);
	Serial.println("Finished Setup");
	delay(1000);

}

void loop() 
{

	if ((elapsedTime - lastUpdate) > updateTime)
	{

		lastUpdate = elapsedTime;
		getIMU();

		PID();

		escPulse1 = throttle_Pulse - rollPulse + pitchPulse + yawPulse;
		escPulse2 = throttle_Pulse - rollPulse - pitchPulse - yawPulse;
		escPulse3 = throttle_Pulse + rollPulse - pitchPulse + yawPulse; 
		escPulse4 = throttle_Pulse + rollPulse + pitchPulse - yawPulse;

		// Set bounds on the motor Pulse 

		// UpperBound 
		if (escPulse1 > 2000)
		{
			escPulse1 = 2000;
		}

		if (escPulse2 > 2000)
		{
			escPulse2 = 2000;
		}

		if (escPulse3 > 2000)
		{
			escPulse3 = 2000;
		}

		if (escPulse4 > 2000)
		{
			escPulse4 = 2000;
		}

		// LowerBound 
		if (escPulse1 < 1100)
		{
			escPulse1 = 1100;
		}

		if (escPulse2 < 1100)
		{
			escPulse2 = 1100;
		}

		if (escPulse3 < 1100)
		{
			escPulse3 = 1100;
		}

		if (escPulse4 < 1100)
		{
			escPulse4 = 1100;
		}



		if(delta5 < 1100)
		{
			escPulse1 = 1000;
			escPulse2 = 1000;
			escPulse3 = 1000;
			escPulse4 = 1000;
		}

		// Convert Mircosecond time to PWM pulse 
		escPulse1PWM = escPulse1*pwmMax/escPulseTime;
		escPulse2PWM = escPulse2*pwmMax/escPulseTime;
		escPulse3PWM = escPulse3*pwmMax/escPulseTime;
		escPulse4PWM = escPulse4*pwmMax/escPulseTime;

		analogWrite(escOut1, escPulse1PWM);
  		analogWrite(escOut2, escPulse2PWM);
  		analogWrite(escOut3, escPulse3PWM);
  		analogWrite(escOut4, escPulse4PWM);
	}	


	if ((elapsedTime - lastPrint) >= printTimer || print == true)
	{
		Serial.println(escPulse1);
	}

}
