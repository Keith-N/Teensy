/* FLIGHT CONTROLLER
 *
 * Testing to see if the desktop 
 * 
 * HARDWARE 
 * TEENSY 3.5 
 * NXP 9DOF ADIAFRUIT IMU 
 * MOTOR TYPE: MULTISTAR 980KV Green Taller 
 *  
 * 
 * CREATED BY:
 * JOSHUA WALLACE, KIETH NASON
 * 
 * 3-21-19 
 * 
*/

// TODO'S 
/* 4-5-19
 * 1. ASK KIETH ABOUT YAW(NOT WORKING PROPERLY BUT NOT NEEDED FOR PID) 
 * 2.  FIND A TO MAKE PULSE 1000 IF CONTROLLER IS NOT ON (NOT WORKING)
 * 3. CHECK CONTROLLER CALIBRATION CODE TO SEE IF SCALING WORKS(NOT WORKING) 
 * 3a. GET GOOD IMU READINGS 
 * 4. PUT PROPELLERS ON AND TEST TO SEE IF CONTROLLER IS WORKING(YES) 
 * 6. Find why: warning: comparison between signed and unsigned integer expressions(ASK MIKE)
*/ 

/////////////////////////////////////////////////////////
//LIBARIES 
/////////////////////////////////////////////////////////
#include <Arduino.h> //Used for Visual Studio's code 
#include <Wire.h>    //I2C communication 
#include <Adafruit_Sensor.h> // IMU libaries 
#include <Adafruit_FXAS21002C.h>
#include <Adafruit_FXOS8700.h>
#include <Mahony.h>	// Filters for IMU
#include <Madgwick.h>
#define AHRS_VARIANT   NXP_FXOS8700_FXAS21002	

/////////////////////////////////////////////////////////
//RANDOM
/////////////////////////////////////////////////////////

elapsedMicros elapsedTime;

/////////////////////////////////////////////////////////
//SWITCHS
/////////////////////////////////////////////////////////
bool debug = false; 

int printTimer = 5000;
int lastPrint = 0;

////////////////////////////////////////////////////////
//PIN DEFINITIONS
////////////////////////////////////////////////////////

// Reciever  
int ch1 = 7;
int ch2 = 8;
int ch3 = 14;
int ch4 = 35;
int ch5 = 33;

// esc
int escOut1 = 5;
int escOut2 = 6;
int escOut3 = 10;
int escOut4 = 20;

// led 
int led = 13; 

// Battery ///NEED TO ADD CODE TO ACCOUNT FOR START OF MOTORS AND BATTERY PLUG IN 
int battery = 2;

/////////////////////////////////////////////////////////
// PWM Variables 
/////////////////////////////////////////////////////////

 // Get maximum value for selected PWM resolution (100% Duty) //ASK KIETH TO LOOK INTO BETTER RESOLUTION
 int pwmMax = 256;
 // Initializing pulse for ESCs, 25% duty
 int escInit = pwmMax/4;

 int pwmFreq = 250;
 int pwmRes = 8;
 int escPulseTime = 4000;

 // Pulse length 
 int escPulse1;
 int escPulse2;
 int escPulse3;
 int escPulse4;

 // Value for analog write function 
 int escPulse1PWM;
 int escPulse2PWM;
 int escPulse3PWM;
 int escPulse4PWM;

 /////////////////////////////////////////////////////////
// IMU 
/////////////////////////////////////////////////////////

 float pitch, roll, yaw;
 float pitch_rate, roll_rate, yaw_rate;

Adafruit_FXAS21002C gyro = Adafruit_FXAS21002C(0x0021002C);
Adafruit_FXOS8700 accelmag = Adafruit_FXOS8700(0x8700A, 0x8700B);

// Calibration 

// Offsets applied to raw x/y/z mag values
 float mag_offsets[3] = { 20.74F, -34.59F, 42.05F };

// Soft iron error compensation matrix
 float mag_softiron_matrix[3][3] = {  { 0.978, -0.035,  0.020 },
                                   	  { -0.035,  0.987, -0.042 },
                                   	  { 0.020, -0.042,  1.039 } };

 float mag_field_strength = 37.27F;

// Offsets applied to compensate for gyro zero-drift error for x/y/z
 float gyro_zero_offsets[3]      = { 0.0F, 0.0F, 0.0F };

// Filter type
 Mahony filter;
 //Madgwick filter;

 // Filter sample rate
 int updateFreq = 250;
 int updateTime = 4000;
 int lastUpdate = 0;

 void getIMU()
{
	 sensors_event_t gyro_event;
	 sensors_event_t accel_event;
	 sensors_event_t mag_event;
	 gyro.getEvent(&gyro_event);
	 accelmag.getEvent(&accel_event, &mag_event);

	 // Apply mag offset compensation (base values in uTesla)
	 float x = mag_event.magnetic.x - mag_offsets[0];
	 float y = mag_event.magnetic.y - mag_offsets[1];
	 float z = mag_event.magnetic.z - mag_offsets[2];

	 // Apply mag soft iron error compensation
	 float mx = x * mag_softiron_matrix[0][0] + y * mag_softiron_matrix[0][1] + z * mag_softiron_matrix[0][2];
	 float my = x * mag_softiron_matrix[1][0] + y * mag_softiron_matrix[1][1] + z * mag_softiron_matrix[1][2];
	 float mz = x * mag_softiron_matrix[2][0] + y * mag_softiron_matrix[2][1] + z * mag_softiron_matrix[2][2];

	 // Apply gyro zero-rate error compensation
	 float gx = gyro_event.gyro.x + gyro_zero_offsets[0];
	 float gy = gyro_event.gyro.y + gyro_zero_offsets[1];
	 float gz = gyro_event.gyro.z + gyro_zero_offsets[2];

	 // The filter library expects gyro data in degrees/s, but adafruit sensor
	 // uses rad/s so we need to convert them first (or adapt the filter lib
	 // where they are being converted)
	 gx *= 57.2958F;
	 gy *= 57.2958F;
	 gz *= 57.2958F;

	filter.update(gx, gy, gz,
				  accel_event.acceleration.x, accel_event.acceleration.y, accel_event.acceleration.z,
				  mx, my, mz);

	 // Degrees  
	 pitch = filter.getRoll();
	 roll = filter.getPitch();
	 yaw = -1*filter.getYaw(); // negative sign added to correct sign convension

	 // Degrees per second 
	 pitch_rate = gyro_event.gyro.x*(180/3.14);
	 roll_rate = gyro_event.gyro.y*(180/3.14);
	 yaw_rate = -1*gyro_event.gyro.z*(180/3.14); // negative sign added to correct sign convension
}

 /////////////////////////////////////////////////////////
 // INTERUPTS
 /////////////////////////////////////////////////////////

 // Timing Variables for Pulse Width
 unsigned long prev1 = 0;
 volatile unsigned int roll_ratePulse = 0;
 unsigned long prev2 = 0;
 volatile unsigned int pitch_ratePulse = 0;
 unsigned long prev3 = 0;
 volatile unsigned int throttle_Pulse = 0;
 unsigned long prev4 = 0;
 volatile unsigned int yaw_ratePulse = 0;
 unsigned long prev5 = 0;
 volatile unsigned int delta5 = 0;		// switch variable name to activate motors....... 


 // Get pulse length 
 // Roll 
 void ch1Int()
{
  if (digitalReadFast(ch1)){
	prev1 = elapsedTime;
  }
  else{
	roll_ratePulse = elapsedTime - prev1;
  }
}

// Pitch 
void ch2Int()
{
  if (digitalReadFast(ch2)){
	prev2 = elapsedTime;
  }
  else{
	pitch_ratePulse = elapsedTime - prev2;
  }
}

// Throttle 
void ch3Int()
{
   if (digitalReadFast(ch3)){
	prev3 = elapsedTime;
   }
   else{
	throttle_Pulse = elapsedTime - prev3;
   }  
}

// Yaw 
void ch4Int()
{
   if (digitalReadFast(ch4)){
	prev4 = micros();
   }
   else{
	yaw_ratePulse = micros() - prev4;
   }
}

// Switch 
void ch5Int()
{
   if (digitalReadFast(ch5)){
	prev5 = elapsedTime;
   }
   else{
	delta5 = elapsedTime - prev5;
   }
}



/////////////////////////////////////////////////////////
// CONTROLLER CALIBRATION
/////////////////////////////////////////////////////////

// add hardcoded receiver values here for each channel 
int throttleLow = 997;
int throttleCenter = 1501;
int throttleHigh  = 1993; 
int throttleDiff = 0;

int roll_rateLow = 1000;
int roll_rateCenter = 1500;
int roll_rateHigh = 2000;

int pitch_rateLow = 1000;
int pitch_rateCenter = 1500;
int pitch_rateHigh = 2000;

int yaw_rateLow = 1000;
int yaw_rateCenter = 1500;
int yaw_rateHigh = 1000;

// COPY JOOPS CODE (JUST COMPLETED THROTTLE)
void getPulse()
{
	if(throttle_Pulse > throttleCenter)
	{
		if(throttle_Pulse > throttleHigh)
		{
			throttle_Pulse = throttleHigh;
		}
		throttleDiff = 500*(throttle_Pulse - throttleCenter)/(throttleHigh - throttleCenter);
		throttle_Pulse = 1500 + throttleDiff;
	}
	else if(throttle_Pulse < throttleCenter)
	{
		if(throttle_Pulse < throttleLow)
		{
			throttle_Pulse = throttleLow;
		}
		throttleDiff = 500*(throttleCenter - throttle_Pulse)/(throttleCenter - throttleLow);
		throttle_Pulse = 1500 - throttleDiff;
	}
}

 /////////////////////////////////////////////////////////
// PID 
/////////////////////////////////////////////////////////

// Pitch Variables 
int inputPitch;
int errorPitch; 
int pitchPulse;
int last_errorPitch;
float Ipitch;

int pPitch = 1;
int dPitch = 18;
int iPitch = 0;

// Roll Variables 
int inputRoll;
int errorRoll; 
int rollPulse;
int last_errorRoll;
int Iroll;

int pRoll = pPitch;
int dRoll = dPitch;
int iRoll = iPitch;

// Yaw Variables 
int inputYaw;
int errorYaw; 
int yawPulse;
int last_errorYaw;
int Iyaw;

int pYaw = 1;
int dYaw = 0;
int iYaw = 0;



void getPID()
{
	// Switched to else if statement(CHECK OUTPUT OF PTICH ROLL AND YAW!!!!)
	// JOOP PUT BOUNDS ON INTERAL TERM (So it doesn't drift to infinity)

	// Pitch
	if(pitch_ratePulse > 1508)
	{
		inputPitch = 1508 - pitch_ratePulse;
	}

	else if(pitch_ratePulse < 1492)
	{
		inputPitch = 1492 - pitch_ratePulse;
	} 
	
	else
	{
		inputPitch = 0;
	}
	errorPitch = 0.33*(inputPitch - pitch_rate);
	Ipitch += iPitch*errorPitch; 
	pitchPulse = pPitch*errorPitch + dPitch*(errorPitch - last_errorPitch) + Ipitch;
	last_errorPitch = errorPitch;

	// Roll 
	if(roll_ratePulse > 1508)
	{
		inputRoll = roll_ratePulse - 1508;
	}

	else if(roll_ratePulse < 1492)
	{
		inputRoll = roll_ratePulse - 1492;
	} 
	
	else
	{
		inputRoll = 0;
	}
	errorRoll = 0.33*(inputRoll - roll_rate);
	Iroll += iRoll*errorRoll;
	rollPulse = pRoll*errorRoll + dRoll*(errorRoll - last_errorRoll) + Iroll;
	last_errorRoll = errorRoll;

	// Yaw
	if(yaw_ratePulse > 1508)
	{
		inputYaw = yaw_ratePulse - 1508 ;
	}

	else if(yaw_ratePulse < 1492)
	{
		inputYaw = yaw_ratePulse - 1492 ;
	} 
	
	else
	{
		inputYaw = 0;
	}
	errorYaw = 0.33*(inputYaw - yaw_rate);
	Iyaw += iYaw*errorYaw;
	yawPulse = pYaw*errorYaw +dYaw*(errorYaw - last_errorYaw) + Iyaw;
	last_errorYaw = errorYaw;
}

void boundPulse()
{
	if (escPulse1 > 2000)
		{
			escPulse1 = 2000;
		}

		if (escPulse2 > 2000)
		{
			escPulse2 = 2000;
		}

		if (escPulse3 > 2000)
		{
			escPulse3 = 2000;
		}

		if (escPulse4 > 2000)
		{
			escPulse4 = 2000;
		}

		// LowerBound 
		if (escPulse1 < 1100)
		{
			escPulse1 = 1100;
		}

		if (escPulse2 < 1100)
		{
			escPulse2 = 1100;
		}

		if (escPulse3 < 1100)
		{
			escPulse3 = 1100;
		}

		if (escPulse4 < 1100)
		{
			escPulse4 = 1100;
		}
}


void setup() 
{
	// Set up Serial monitor 
	if(debug == true)  
	{
		Serial.begin(115200);
		while(!Serial);
		Serial.println("DEBUGING");
	}

	// Set pin direction 
	pinMode(ch1,INPUT);
	pinMode(ch2,INPUT);
	pinMode(ch3,INPUT);
	pinMode(ch4,INPUT);

	pinMode(escOut1,OUTPUT);
	pinMode(escOut2,OUTPUT);
	pinMode(escOut3,OUTPUT);
	pinMode(escOut4,OUTPUT);

	pinMode(led,OUTPUT);
	pinMode(battery,INPUT);

	//Setup rx pin interrupts
  	attachInterrupt(ch1,ch1Int,CHANGE);
  	attachInterrupt(ch2,ch2Int,CHANGE);
  	attachInterrupt(ch3,ch3Int,CHANGE);
  	attachInterrupt(ch4,ch4Int,CHANGE);
	attachInterrupt(ch5,ch5Int,CHANGE);

	//Check to see if the controller is turned on 
	// while(delta5 < 1600)
	// {
	// 	// Fast LED until controller is turned on 
	// 	digitalWrite(led,HIGH);
	// 	delay(250);
	// 	digitalWrite(led,LOW);
	// 	delay(250);
	// }



	// Initilize IMU 
	if(!gyro.begin(GYRO_RANGE_500DPS))
	{
		/* There was a problem detecting the gyro ... check your connections */
		Serial.println("Ooops, no gyro detected ... Check your wiring!");
		while(1);
	}

	if(!accelmag.begin(ACCEL_RANGE_4G))
	{
		Serial.println("Ooops, no FXOS8700 detected ... Check your wiring!");
		while(1);
	}

	filter.begin(updateFreq);

	// Wait for battery to be plugged in 
	// while(digitalRead(battery) == 0);

	
	// All on Timer FTM0 -> pwmFreq
  	analogWriteFrequency(escOut1, pwmFreq);

  	// Set PWM resolution
  	analogWriteResolution(pwmRes);
	
	// Initialize ESCs
  	analogWrite(escOut1, escInit);
  	analogWrite(escOut2, escInit);
  	analogWrite(escOut3, escInit);
  	analogWrite(escOut4, escInit);
  	delay(5000);
	Serial.println("ESC Initialization completed");

	


	// Setup complete 
	digitalWrite(led,HIGH);
	Serial.println("Finished Setup");
	delay(1000);

}

void loop() 
{

	if ((elapsedTime - lastUpdate) > updateTime)
	{

		lastUpdate = elapsedTime;

		// Get the rates and angles
		getIMU();

		// getPulse(); CURRENTLY DOES NOT WORK

		getPID();

		escPulse1 = throttle_Pulse - rollPulse + pitchPulse + yawPulse;
		escPulse2 = throttle_Pulse - rollPulse - pitchPulse - yawPulse;
		escPulse3 = throttle_Pulse + rollPulse - pitchPulse + yawPulse; 
		escPulse4 = throttle_Pulse + rollPulse + pitchPulse - yawPulse;

		boundPulse();

		// Turn quad on or off 
		if(delta5 < 1110)
		{
			escPulse1 = 1000;
			escPulse2 = 1000;
			escPulse3 = 1000;
			escPulse4 = 1000;
		}

		// Convert Mircosecond time to PWM pulse for motors
		escPulse1PWM = escPulse1*pwmMax/escPulseTime;
		escPulse2PWM = escPulse2*pwmMax/escPulseTime;
		escPulse3PWM = escPulse3*pwmMax/escPulseTime;
		escPulse4PWM = escPulse4*pwmMax/escPulseTime;

		// Send PWM pulse to motors
		analogWrite(escOut1, escPulse1PWM);
  		analogWrite(escOut2, escPulse2PWM);
  		analogWrite(escOut3, escPulse3PWM);
  		analogWrite(escOut4, escPulse4PWM);
	}	

	if (debug == true)
	{
		// Print variables here 
		if ((elapsedTime - lastPrint) >= printTimer)
		{
			lastPrint = elapsedTime;
			Serial.println(escPulse4);
		}
	}
}
